From 82e703dd438b71432cc0ccbb90925d1e32dd014a Mon Sep 17 00:00:00 2001
From: Christian Marangi <ansuelsmth@gmail.com>
Date: Thu, 9 Jan 2025 14:12:57 +0100
Subject: [PATCH] pmdomain: airoha: Add Airoha CPU PM Domain support

Add Airoha CPU PM Domain support to control frequency and power of CPU
present on Airoha EN7581 SoC.

Frequency and power can be controlled with the use of the SMC command by
passing the performance state. The driver also expose a read-only clock
that expose the current CPU frequency with SMC command.

Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
Link: https://lore.kernel.org/r/20250109131313.32317-1-ansuelsmth@gmail.com
Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
---
 drivers/pmdomain/mediatek/Kconfig             |  12 ++
 drivers/pmdomain/mediatek/Makefile            |   1 +
 .../pmdomain/mediatek/airoha-cpu-pmdomain.c   | 144 ++++++++++++++++++
 3 files changed, 157 insertions(+)
 create mode 100644 drivers/pmdomain/mediatek/airoha-cpu-pmdomain.c

--- a/drivers/soc/mediatek/Kconfig
+++ b/drivers/soc/mediatek/Kconfig
@@ -2,6 +2,17 @@
 #
 # MediaTek SoC drivers
 #
+config AIROHA_CPU_PM_DOMAIN
+	tristate "Airoha CPU power domain"
+	default ARCH_AIROHA
+	depends on PM
+	select PM_GENERIC_DOMAINS
+	help
+	  Say y here to enable CPU power domain support for Airoha SoC.
+
+	  CPU frequency and power is controlled by ATF with SMC command to
+	  set performance states.
+
 menu "MediaTek SoC drivers"
 	depends on ARCH_MEDIATEK || COMPILE_TEST
 
--- a/drivers/pmdomain/mediatek/Makefile
+++ b/drivers/pmdomain/mediatek/Makefile
@@ -1,3 +1,4 @@
 # SPDX-License-Identifier: GPL-2.0-only
 obj-$(CONFIG_MTK_SCPSYS)		+= mtk-scpsys.o
 obj-$(CONFIG_MTK_SCPSYS_PM_DOMAINS) 	+= mtk-pm-domains.o
+obj-$(CONFIG_AIROHA_CPU_PM_DOMAIN) 	+= airoha-cpu-pmdomain.o
--- /dev/null
+++ b/drivers/pmdomain/mediatek/airoha-cpu-pmdomain.c
@@ -0,0 +1,311 @@
+// SPDX-License-Identifier: GPL-2.0
+
+#include <linux/bitfield.h>
+#include <linux/clk-provider.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/pm_domain.h>
+#include <linux/slab.h>
+
+/*
+ * CPU PLL registers in chip-SCU region (base 0x1fa20000).
+ * Reversed from ATF BL31 en7523_armpll_set() / curr_armpll_clk_get().
+ */
+#define CHIP_SCU_BASE			0x1fa20000
+#define CHIP_SCU_SIZE			0x2c0
+
+#define CPUPLL_CLK_MUX			0x1e0
+#define PLLRG_PROTECT			0x268
+#define CPUPLL_SDM_PCW			0x2b4
+#define CPUPLL_SDM_PCW_CHG		0x2b8
+
+/* SDM_PCW: bits[30:24] = PCW integer multiplier */
+#define CPUPLL_PCW_INT_MASK		GENMASK(30, 24)
+#define CPUPLL_XTAL_MHZ		50
+
+/* SDM_PCW_CHG: bits[6:4] = post-divider, bit[0] = change toggle */
+#define CPUPLL_CHG_BIT			BIT(0)
+#define CPUPLL_CHG_POSDIV_MASK		GENMASK(6, 4)
+
+/* PLLRG_PROTECT: write 0x12 to unlock, 0x00 to lock */
+#define PLLRG_PROTECT_MASK		GENMASK(7, 0)
+#define PLLRG_PROTECT_KEY		0x12
+
+/*
+ * MCUCFG clock switch registers (base 0x1efbe000).
+ * ATF uses these to switch CPU between armpll and backup PLL2 (400 MHz).
+ */
+#define MCUCFG_BASE			0x1efbe000
+#define MCUCFG_SIZE			0x800
+
+#define MCUCFG_CK_SWITCH_UNLOCK	0x640
+#define MCUCFG_CK_SOURCE_SEL		0x7c0
+
+#define MCUCFG_CK_UNLOCK_KEY		0x12
+#define MCUCFG_CK_SEL_MASK		GENMASK(10, 9)
+#define MCUCFG_CK_SEL_ARMPLL		1
+#define MCUCFG_CK_SEL_PLL2		3
+
+struct airoha_cpu_pmdomain_priv {
+	struct clk_hw hw;
+	struct generic_pm_domain pd;
+	void __iomem *pll_base;	/* chip-scu */
+	void __iomem *mcucfg;		/* MCUCFG */
+};
+
+static long airoha_cpu_pmdomain_clk_round(struct clk_hw *hw,
+					   unsigned long rate,
+					   unsigned long *parent_rate)
+{
+	return rate;
+}
+
+/*
+ * Read current CPU PLL frequency from hardware.
+ * freq = pcw_int * XTAL / (1 << posdiv)
+ */
+static unsigned long airoha_cpu_pmdomain_clk_get(struct clk_hw *hw,
+						 unsigned long parent_rate)
+{
+	struct airoha_cpu_pmdomain_priv *priv =
+		container_of(hw, struct airoha_cpu_pmdomain_priv, hw);
+	u32 pcw, chg;
+	unsigned int pcw_int, posdiv;
+
+	pcw = readl(priv->pll_base + CPUPLL_SDM_PCW);
+	pcw_int = FIELD_GET(CPUPLL_PCW_INT_MASK, pcw);
+
+	chg = readl(priv->pll_base + CPUPLL_SDM_PCW_CHG);
+	posdiv = FIELD_GET(CPUPLL_CHG_POSDIV_MASK, chg);
+
+	return (unsigned long)pcw_int * CPUPLL_XTAL_MHZ * 1000000UL >>
+	       posdiv;
+}
+
+static int airoha_cpu_pmdomain_clk_is_enabled(struct clk_hw *hw)
+{
+	return true;
+}
+
+static const struct clk_ops airoha_cpu_pmdomain_clk_ops = {
+	.recalc_rate = airoha_cpu_pmdomain_clk_get,
+	.is_enabled = airoha_cpu_pmdomain_clk_is_enabled,
+	.round_rate = airoha_cpu_pmdomain_clk_round,
+};
+
+/*
+ * Switch CPU clock source via CLK_MUX and MCUCFG registers.
+ * Matches ATF BL31 clock_switch() (FUN_8000a174) which:
+ *   1. Enables target PLL output path in CLK_MUX (FUN_8000a0f4)
+ *   2. Unlocks MCUCFG clock switch register
+ *   3. Selects target clock source in MCUCFG
+ *
+ * sel=MCUCFG_CK_SEL_ARMPLL (1): CLK_MUX bit 0 = ARMPLL path
+ * sel=MCUCFG_CK_SEL_PLL2 (3):   CLK_MUX bit 2 = PLL2 path
+ */
+static void airoha_cpu_clock_switch(void __iomem *pll_base,
+				    void __iomem *mcucfg, unsigned int sel)
+{
+	u32 val;
+
+	/* Enable target PLL output path in CLK_MUX (ATF FUN_8000a0f4) */
+	if (sel != 0) {
+		val = readl(pll_base + CPUPLL_CLK_MUX);
+		writel(val | BIT(sel - 1), pll_base + CPUPLL_CLK_MUX);
+	}
+
+	/* Unlock MCUCFG clock switch */
+	val = readl(mcucfg + MCUCFG_CK_SWITCH_UNLOCK);
+	writel((val & ~0x1f) | MCUCFG_CK_UNLOCK_KEY,
+	       mcucfg + MCUCFG_CK_SWITCH_UNLOCK);
+
+	/* Select clock source */
+	val = readl(mcucfg + MCUCFG_CK_SOURCE_SEL);
+	val &= ~MCUCFG_CK_SEL_MASK;
+	val |= FIELD_PREP(MCUCFG_CK_SEL_MASK, sel);
+	writel(val, mcucfg + MCUCFG_CK_SOURCE_SEL);
+}
+
+/*
+ * Set CPU PLL frequency by OPP performance state (index 0-14).
+ * OPP table: state 0 = 500 MHz ... state 14 = 1200 MHz (50 MHz steps).
+ *
+ * The PLL VCO must stay >= 1000 MHz, so a post-divider is used:
+ *   States 0-9  (500-950 MHz):  posdiv=1 (VCO/2), pcw = freq/25
+ *   States 10-14 (1000-1200 MHz): posdiv=0 (VCO/1), pcw = freq/50
+ *
+ * Sequence reversed from ATF BL31 en7523_armpll_set() (FUN_8000a2c8):
+ * 1. Enable PLL2 path in CLK_MUX, switch CPU to PLL2 via MCUCFG
+ * 2. Unlock PLL register protection
+ * 3. Write new PCW integer
+ * 4. Write posdiv and toggle CHG bit (edge-triggered)
+ * 5. Wait for PLL to lock
+ * 6. Enable ARMPLL path in CLK_MUX, switch CPU back to ARMPLL via MCUCFG
+ * 7. Clear PLL2 path bit and bit 2 of CLK_MUX
+ * 8. Re-lock PLL register protection
+ */
+static int airoha_cpu_pmdomain_set_performance_state(
+		struct generic_pm_domain *domain, unsigned int state)
+{
+	struct airoha_cpu_pmdomain_priv *priv =
+		container_of(domain, struct airoha_cpu_pmdomain_priv, pd);
+	void __iomem *base = priv->pll_base;
+	unsigned int freq_mhz = 500 + state * 50;
+	unsigned int posdiv, pcw_int;
+	unsigned long flags;
+	u32 val, old_chg, cleared;
+
+	if (freq_mhz < 1000) {
+		posdiv = 1;
+		pcw_int = freq_mhz / 25;
+	} else {
+		posdiv = 0;
+		pcw_int = freq_mhz / 50;
+	}
+
+	local_irq_save(flags);
+
+	/* Step 1: Enable PLL2 path + switch CPU to PLL2 (400 MHz) */
+	airoha_cpu_clock_switch(base, priv->mcucfg, MCUCFG_CK_SEL_PLL2);
+
+	/* Step 2: Unlock PLL registers */
+	val = readl(base + PLLRG_PROTECT);
+	writel((val & ~PLLRG_PROTECT_MASK) | PLLRG_PROTECT_KEY,
+	       base + PLLRG_PROTECT);
+
+	/* Step 3: Write new PCW integer value */
+	val = readl(base + CPUPLL_SDM_PCW);
+	val &= ~CPUPLL_PCW_INT_MASK;
+	val |= FIELD_PREP(CPUPLL_PCW_INT_MASK, pcw_int);
+	writel(val, base + CPUPLL_SDM_PCW);
+
+	/*
+	 * Step 4: Write posdiv and toggle CHG bit.
+	 * ATF logic: clear posdiv bits, set new posdiv, then toggle
+	 * CHG bit (if was 0 set to 1, if was 1 clear to 0).
+	 */
+	old_chg = readl(base + CPUPLL_SDM_PCW_CHG);
+	cleared = old_chg & ~(CPUPLL_CHG_POSDIV_MASK | CPUPLL_CHG_BIT);
+	if (old_chg & CPUPLL_CHG_BIT)
+		writel(cleared | FIELD_PREP(CPUPLL_CHG_POSDIV_MASK, posdiv),
+		       base + CPUPLL_SDM_PCW_CHG);
+	else
+		writel(cleared | FIELD_PREP(CPUPLL_CHG_POSDIV_MASK, posdiv) |
+		       CPUPLL_CHG_BIT, base + CPUPLL_SDM_PCW_CHG);
+
+	/* Step 5: Wait for PLL to lock */
+	udelay(20);
+
+	/* Step 6: Enable ARMPLL path + switch CPU back to ARM PLL */
+	airoha_cpu_clock_switch(base, priv->mcucfg, MCUCFG_CK_SEL_ARMPLL);
+
+	/* Step 7: Clear PLL2 path bit in CLK_MUX (matches ATF) */
+	val = readl(base + CPUPLL_CLK_MUX);
+	writel(val & ~BIT(2), base + CPUPLL_CLK_MUX);
+
+	/* Step 8: Re-lock PLL registers */
+	val = readl(base + PLLRG_PROTECT);
+	writel(val & ~PLLRG_PROTECT_MASK, base + PLLRG_PROTECT);
+
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+static int airoha_cpu_pmdomain_probe(struct platform_device *pdev)
+{
+	struct airoha_cpu_pmdomain_priv *priv;
+	struct device *dev = &pdev->dev;
+	const struct clk_init_data init = {
+		.name = "cpu",
+		.ops = &airoha_cpu_pmdomain_clk_ops,
+		.flags = CLK_GET_RATE_NOCACHE,
+	};
+	struct generic_pm_domain *pd;
+	unsigned long freq_hz;
+	int ret;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->pll_base = devm_ioremap(dev, CHIP_SCU_BASE, CHIP_SCU_SIZE);
+	if (!priv->pll_base)
+		return dev_err_probe(dev, -ENOMEM,
+				     "failed to map chip-scu registers\n");
+
+	priv->mcucfg = devm_ioremap(dev, MCUCFG_BASE, MCUCFG_SIZE);
+	if (!priv->mcucfg)
+		return dev_err_probe(dev, -ENOMEM,
+				     "failed to map MCUCFG registers\n");
+
+	/* Verify PLL register returns sane frequency */
+	priv->hw.init = &init;
+	freq_hz = airoha_cpu_pmdomain_clk_get(&priv->hw, 0);
+	if (!freq_hz || freq_hz > 2000000000UL)
+		return dev_err_probe(dev, -ENODEV,
+				     "invalid CPU PLL frequency: %lu Hz\n",
+				     freq_hz);
+
+	dev_info(dev, "CPU PLL frequency: %lu MHz\n", freq_hz / 1000000);
+
+	ret = devm_clk_hw_register(dev, &priv->hw);
+	if (ret)
+		return ret;
+
+	ret = devm_of_clk_add_hw_provider(dev, of_clk_hw_simple_get,
+					  &priv->hw);
+	if (ret)
+		return ret;
+
+	pd = &priv->pd;
+	pd->name = "cpu_pd";
+	pd->flags = GENPD_FLAG_ALWAYS_ON;
+	pd->set_performance_state = airoha_cpu_pmdomain_set_performance_state;
+
+	ret = pm_genpd_init(pd, NULL, false);
+	if (ret)
+		return ret;
+
+	ret = of_genpd_add_provider_simple(dev->of_node, pd);
+	if (ret)
+		goto err_add_provider;
+
+	platform_set_drvdata(pdev, priv);
+	return 0;
+
+err_add_provider:
+	pm_genpd_remove(pd);
+	return ret;
+}
+
+static void airoha_cpu_pmdomain_remove(struct platform_device *pdev)
+{
+	struct airoha_cpu_pmdomain_priv *priv = platform_get_drvdata(pdev);
+
+	of_genpd_del_provider(pdev->dev.of_node);
+	pm_genpd_remove(&priv->pd);
+}
+
+static const struct of_device_id airoha_cpu_pmdomain_of_match[] = {
+	{ .compatible = "airoha,en7581-cpufreq" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, airoha_cpu_pmdomain_of_match);
+
+static struct platform_driver airoha_cpu_pmdomain_driver = {
+	.probe = airoha_cpu_pmdomain_probe,
+	.remove_new = airoha_cpu_pmdomain_remove,
+	.driver = {
+		.name = "airoha-cpu-pmdomain",
+		.of_match_table = airoha_cpu_pmdomain_of_match,
+	},
+};
+module_platform_driver(airoha_cpu_pmdomain_driver);
+
+MODULE_AUTHOR("Christian Marangi <ansuelsmth@gmail.com>");
+MODULE_DESCRIPTION("CPU PM domain driver for Airoha SoCs");
+MODULE_LICENSE("GPL");
